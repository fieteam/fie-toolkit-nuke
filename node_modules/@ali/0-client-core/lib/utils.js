var 
	path = require("path"),
	fs = require("fs"),
	http = require('http'),
    
    colors = require('colors'),
    temp = require("temp"),
	Q = require('q'),
    unzip = require('unzip'),
    merge = require('merge'),

    /**
     * 工具类
     */
	utils = {
        /**
         * 创建深层目录
         * @param dirname {string} 目录名
         * @param mode {string} 权限
         * @returns {boolean}
         * @example
         * mkdirsSync('/home/user/xxxx');
         */
		mkdirsSync : function(dirname, mode){
		    if(fs.existsSync(dirname)){
		        return true;
		    }else{
		        if(arguments.callee(path.dirname(dirname), mode)){
		            fs.mkdirSync(dirname, mode);
		            return true;
		        }
		    }
		},
        /**
         * 发起 HTTP GET 请求并返回结果
         * @param opts {object} 参数集合
         * @param opt.url {string} 请求地址
         * @param opt.callback {function} 请求回调 return { text , response }
         * @param opt.error 请求错误回调 {function} return { url , response }
         * @returns request
         */
		httpGet : function(opts){

			var request = http.get(opts.url, function(res) {

				// 异常判断
				if (res.statusCode != 200) {
					opts.error( { url : opts.url, response : res} );
					return false;
				}

				// 接收
				res.setEncoding('utf8');
				var str = '';

				res.on('data', function (chunk) {
					str += chunk;
				});

				res.on('end', function () {
					opts.callback({ text : str, response : res });
				});
			}).on("error", function (error){

				opts.error( { url : opts.url, error : error } );

			});

			// 超时处理
			if(opts.timeout){
				request.setTimeout(opts.timeout, function () {
					request.abort();
				});
			}

			return request;
		},
        /**
         * 发起 HTTP GET 请求并返回结果 - Promise 封装
         * @param url {string} 请求地址
         * @returns promise
         */
		promiseHttpGet : function (url) {
			var deferred = Q.defer();

			utils.httpGet({url : url , callback : deferred.resolve, error : deferred.reject});

			return deferred.promise;
		},
        
        /**
         * 下载文件
         * @param args {object} 参数集合
         * @param args.url {string} 下载文件地址
         * @param [args.savePath] {string} 本地保存地址(包含扩展名的完整路径) 注意：不指定则下载到用户临时目录
         * @param [args.timeout] {Number} 获取种子超时时间(默认:3000ms)
         * @return promise
         * @example
    
            utils.download({
                url : 'http://0.alif2e.com/download.zip?gitlabProjectPath=seed/example-new',
                savePath : './download/example-new.zip'
            }).then(function(cb){
                console.log(cb);
            },function(error){
                console.log(error);
            });
         
         */
        download : function(args){
            
            // 新建许诺
            var deferred = Q.defer();
            
            var // 种子地址
                url =  args.url,
                // 存放种子路径
                savePath = args.savePath,
                // 超时时间(ms)
                timeout = args.timeout ? args.timeout : 30000,
                // 额外信息容器
                extraInfo = {}
                ;
        
            // 开始下载云端种子
            var request = http.get(url, function(response) {
        
                if (response.statusCode === 200) {
        
                    // 异常处理
                    if(response.headers.downloaderror == '404'){
                        return deferred.reject({
                            error : '下载种子异常，也许您下载的是一个空种子。'
                        });return deferred.promise;
                    }
        
                    // 正常内容
                    if( response.headers['content-type'] = 'application/octet-stream' ){
                        
                        // 创建写入目录
                        var savePathDir= path.dirname(savePath);
                        if(!fs.existsSync( savePathDir )){
                            utils.mkdirsSync(savePathDir);
                        }
                        
                        // 下载包HEADER是否携带额外信息
                        if(response.headers['extra-info']){
                            // 合入remoteSeedInfo
                            extraInfo = JSON.parse(response.headers['extra-info']);
                        }
                        
                        // 正常下载
                        var file = fs.createWriteStream(savePath);
                        var downloadPipe = response.pipe(file);
                        // 完成回调
                        downloadPipe.on('close',function(){
        
                            // 成功返回许诺
                            deferred.resolve(merge(true,args,{
                                extraInfo : extraInfo
                            }));
        
                        });
                    }else{
                        deferred.reject({
                            error : '下载文件类型异常，可能是云端种子库服务异常。'
                        });return deferred.promise;
                    }
        
                }else{
                    deferred.reject({
                        error : '下载种子出错，可能是云端种子库服务异常。'
                    });return deferred.promise;
                }
        
        
            });
        
            // 请求出错
            request.on("error", function (error){
                deferred.reject({
                    error : '云端种子库服务异常。'
                });return deferred.promise;
            });
        
            // 超时处理
            request.setTimeout(timeout, function(){
                request.abort();
                deferred.reject({
                    error : '获取种子文件超时，或许与云端服务有关。'
                });return deferred.promise;
            });
        
            
            // 返回许诺
            return deferred.promise;
            
        },
        
        /**
         * 下载文件到临时目录
         * @param args {object} 参数集合
         * @param args.url {string} 下载文件地址
         * @param [args.timeout] {Number} 获取种子超时时间(默认:3000ms)
         * @return promise
         * @example
    
            utils.downloadToTemp({
                url : 'http://0.alif2e.com/download.zip?gitlabProjectPath=seed/example-new'
            }).then(function(cb){
                console.log(cb);
            },function(error){
                console.log(error);
            });
         
         */
        downloadToTemp : function(args){
            
            // 新建许诺
            var 
                tempDir = temp.mkdirSync('temp'),
                fileName = path.basename(args.url).split('?')[0]
                ;
            
            // 清理临时文件
            temp.track();
            
            return utils.download({
                url : args.url,
                savePath : path.join( tempDir, fileName )
            });
            
        },
        
        /**
         * 解压zip文件
         * @param args {object} 参数集合
         * @param args.zipPath {string} zip压缩包地址
         * @param args.outputPath {string} 解压到本地保存地址
         * @return promise
         * @example
    
            utils.unzip({
                zipPath : './download/example-new.zip',
                outputPath : './unzip/example-new'
            }).then(function(cb){
                console.log(cb);
            })
         
         */
        unzip : function(args){
            
            // 新建许诺
            var deferred = Q.defer();
            
            var unzipExtractor = unzip.Extract({ path: args.outputPath }),
                unZipPipe = fs.createReadStream(args.zipPath).pipe(unzipExtractor)
                ;
            
            unZipPipe.on('close',function(){
                // 成功返回许诺
                deferred.resolve(merge(true,args,{}));
            });
            
            // 返回许诺
            return deferred.promise;
            
        },
        
        /**
         * 深层创建目录并写入文件。
         * @param filePath {string} 文件路径
         * @param data {data} 数据
         * @param opt {object} 写入参数
         */
		writeFileSync : function( filePath, data , opt ){
			// 解析出文件的目录路径
			
			var fileDirPath = path.dirname(filePath);
			if(!fs.existsSync( fileDirPath )){
				this.mkdirsSync(fileDirPath);
			}

			fs.writeFileSync( filePath , data , opt);

		},

        /**
         * 遍历目录 travel 
         * from http://nqdeng.github.io/7-days-nodejs/
         * @param dir
         * @param callback
         * @example 
            travel('/home/user', function (pathname) {
                console.log(pathname);
            });
         */
		travel : function(dir, callback) {
			var travelFunction = arguments.callee;
		    fs.readdirSync(dir).forEach(function (file) {
		        var pathname = path.join(dir, file);
		        if (fs.statSync(pathname).isDirectory()) {
					travelFunction(pathname, callback);
		        } else {
		            callback(pathname);
		        }
		    });
		},
        
        /**
         * 显示错误
         * @param text
         * @returns {string}
         */
		errorInfo : function(text){
			var errorText = '[error]'.red + ' ' + text;
			console.log( errorText );
			return errorText;
		},
        
        /**
         * 显示信息
         * @param text
         * @returns {string}
         */
		info : function(text){
			var infoText = '[info]'.green + ' ' + text;
			console.log( infoText );
			return infoText;
		},
        
        /**
         * 判断是否是通常需要跳过的文件
         * @param itemName
         * @returns {boolean}
         */
		isIgnore : function(itemName){

			if('|.DS_Store|.git|.svn|.idea|'.indexOf( '|' + itemName + '|' ) != -1){
				return true;
			}
			return false;
		},
        
        /**
         * 字符串是否在数组中
         * @param theStr
         * @param theArray
         * @returns {boolean}
         */
		isStrInArray : function( theStr , theArray){
			return ('|' + theArray.join('|') + '|').indexOf('|' + theStr + '|') != -1;
		},
        
        /**
         * 超链接 应该加 & 或 ?
         * @param linkStr
         * @returns {*}
         */
		strJoinlink : function(linkStr){
			if(linkStr.indexOf('?') != -1){
				return '&';
			}else{
				return '?';
			}
		},
        
        /**
         * 转大驼峰
         * @param string
         * @returns {string}
         */
		toUpperCamelCase : function(string){
            if(typeof(string) != 'string')return string;
            
			var LCCString =  utils.toLowCamelCase(string),
				stringLength = LCCString.length,
				firstChar = LCCString.substring(0,1).toUpperCase(),
				endString = LCCString.substring(1,stringLength)
				;

			return firstChar + endString;

		},
        
        /**
         * 转小驼峰
         * @param string
         * @returns {string|void|XML}
         */
		toLowCamelCase : function(string){
            if(typeof(string) != 'string')return string;
			return string.replace(/-(\w)/g, function (all, letter) {
				return letter.toUpperCase();
			});

		},
        
        /**
         * 格式化时间
         * @param timeValue
         * @param fmt
         * @returns {*}
         */
		timeFormat : function (timeValue,fmt) {
			var time =  new Date(timeValue);
			var o = {
				"M+": time.getMonth() + 1, //月份
				"d+": time.getDate(), //日
				"h+": time.getHours(), //小时
				"m+": time.getMinutes(), //分
				"s+": time.getSeconds(), //秒
				"q+": Math.floor((time.getMonth() + 3) / 3), //季度
				"S": time.getMilliseconds() //毫秒
			};
			if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (time.getFullYear() + "").substr(4 - RegExp.$1.length));
			for (var k in o)
				if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
			return fmt;
		},
        
        /**
         * 扁平化数据
         * @param data {object} 传入的数据
         * @returns {object}
         */
        flattenData : function(data) {
            var result = {};
            function recurse (cur, prop) {
                if (Object(cur) !== cur) {
                    result[prop] = cur;
                } else if (Array.isArray(cur)) {
                     for(var i=0, l=cur.length; i<l; i++)
                         recurse(cur[i], prop + "[" + i + "]");
                    if (l == 0)
                        result[prop] = [];
                } else {
                    var isEmpty = true;
                    for (var p in cur) {
                        isEmpty = false;
                        recurse(cur[p], prop ? prop+"."+p : p);
                    }
                    if (isEmpty)
                        result[prop] = {};
                }
            }
            recurse(data, "");
            return result;
        },
        
        replaceAll : function(content,regexp,value){
            var replaceRegx = new RegExp(regexp.replace(/\./g,'\\.').replace(/\(/g,'\\(').replace(/\)/,'\\)'),"g");
            return content.replace(replaceRegx,value);
        }
        
        

	};

module.exports = utils;